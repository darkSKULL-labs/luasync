$Id: io.txt,v 1.3 2006-06-04 22:23:59 ezdy Exp $
Disk I/O interface
------------------
io.open(fname, "rwcx")
	open given fname, flags:
		r - for reading
		w - for writing
		c - create
		x - exclude (for create)

io.stat(fname)
	returns a pseudo-table with follwing keys:
	dev, ino, mode, nlink, uid, gid, rdev, atime, mtime, ctime, size, blocks, blksize
	the names are self-explanatory. consult man page for stat() for more.
	mode is in ls format, that is: 'drwxrwxrwx'. additionaly, you can use following pseudomacros:
	XOTH
	WOTH
	ROTH
	XGRP
	WGRP
	RGRP
	XOWN
	WOWN
	ROWN
	to check exact permissions.
	ISUID
	ISGID
	ISVTX
	to check setuid/gid/sticky bits
	IFSOCK
	IFLNK
	IFREG
	IFBLK
	IFDIR
	IFCHR
	IFIFO
	to check additional info about file.

io.lstat(fname)
	same as above, but dont dereference symlinks

io.fstat(fd)
	same as stat, but for opened fd

io.read(fd, buf, count[, offset])
	returns a buffer with data read

io.write(fd, buf[, offset])
	returns number of bytes written

io.sendfile(from, to, offset[, count]])
	sendfile from fiel to socket 'to'.
	offset is where to start and count is maximum
	limit to be sent.

io.seek(fd, [offset[, "bes"]])
	seek in file at position
		s - since start 
		e - since end
		c - since current
io.close(fd)
	close the file handle, freeing any resources associated with it.

io.lsdir(fname)
	returns a directory-reading iterator

io.dir([newdir])
	tell us current directory, or change to new directory 'newdir'

io.unlink(fname)
	remove given file

io.rmdir(fname)
	remove given directory (must be empty)

io.chmod(fname, mode)
io.fchmod(fd, mode)
	change permissions

io.chown(fname, uid, gid)
io.fchown(fd, uid, gid)
io.lchown(fname, uid, gid)
	change owner. either uid or gid can be omitted with nil or -1
io.readlink(fname)
	returns symbolic link target (as a string)

Disk AIO interface
------------------
The following is provided to handle aio:
aio.open, aio.stat, aio.lstat, aio.fstat, aio.read, aio.write,

they return an event object (see event.txt) which will be returned
whenever aio completes. returned values are as follows:

ev, result, error = event.poll()

the ev is completely different from socket events, so you must treat it so. final loop looks like:

aioq[aio.open("blahblah")] = context

...

for ev, r, w in event.poll do
	-- lookup the aio event table
	local ctx = aioq[ev];
	if (ctx) then
		if (not w) then
			process_aio(ctx, r);
		end
		aioq[ev] = nil
	else

		if (r) then
			process_read(ev);
		end

		if (w) then
			process_write(ev);
		end
	end
end

